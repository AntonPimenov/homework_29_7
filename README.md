# Проектирование многопоточных структур данных

## Задание:
   Напишите реализацию метода insertIntoMiddle(int value, int pos) для списка мелкогранулярной блокировкой. Часть кода уже написана — сама структура списка взята из юнита про мелкогранулярную блокировку и приведена ниже.

    struct Node
    {
      int value;
      Node* next;
      std::mutex* node_mutex;
    };

    class FineGrainedQueue
    {
      Node* head;
      std::mutex* queue_mutex;
    };

    Функция должна вставить узел с переданным значением value в позицию pos. Чтобы не переусложнять реализацию, предполагается следующее:

        очередь не пустая,
        вставляется элемент в середину или конец списка, то есть вставку в начало списка не нужно рассматривать,
        если pos больше длины списка, то нужно вставить элемент в конец списка.

## Реализация метода insertIntoMiddle(int value, int pos) для списка с мелкогранулярной блокировкой требует аккуратной работы с мьютексами, чтобы избежать взаимоблокировок (deadlocks) и обеспечить потокобезопасность.
Алгоритм:

    Заблокировать queue_mutex, чтобы безопасно получить доступ к head.

    Пройти по списку, поочередно блокируя узлы, пока не найдем нужную позицию.

    Вставить новый узел, сохраняя порядок списка.

    Разблокировать все мьютексы в обратном порядке.

## Объяснение кода:

    Структура Node:

        Хранит value, указатель next и мьютекс (node_mutex).

        Мьютекс защищает доступ к узлу при многопоточной вставке.

    Класс FineGrainedQueue:

        head — начало списка.

        queue_mutex — защищает доступ к head при изменении структуры списка.

        insertIntoMiddle(int value, int pos):

            Создает новый узел.

            Блокирует queue_mutex, чтобы безопасно получить head.

            Поочередно блокирует узлы, пока не достигнет позиции pos (или конца списка).

            Вставляет новый узел и разблокирует мьютексы.

        printList() — выводит список (не потокобезопасный, только для демонстрации).

    Функция main:

        Создает список 1 -> 3 -> 5.

        Вставляет 10 в позицию 2 → 1 -> 10 -> 3 -> 5.

        Вставляет 20 в конец (позиция 100) → 1 -> 10 -> 3 -> 5 -> 20.

        Запускает три потока для вставки 30, 40, 50 в разные позиции.

        Выводит итоговый список (порядок зависит от планировщика потоков).    